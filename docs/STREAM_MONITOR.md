# å¹¶å‘æ’­æ”¾ç›‘æ§åŠŸèƒ½

> **ç‰ˆæœ¬**: v1.0
> **æ›´æ–°æ—¥æœŸ**: 2025-11-25
> **é€‚ç”¨å¯¹è±¡**: ç®¡ç†å‘˜

---

## ğŸ“– ç›®å½•

- [åŠŸèƒ½æ¦‚è¿°](#åŠŸèƒ½æ¦‚è¿°)
- [å®ç°åŸç†](#å®ç°åŸç†)
- [æ–‡ä»¶æ¸…å•](#æ–‡ä»¶æ¸…å•)
- [é…ç½®è¯´æ˜](#é…ç½®è¯´æ˜)
- [ä»£ç å®ç°](#ä»£ç å®ç°)
- [ä½¿ç”¨æ–¹æ³•](#ä½¿ç”¨æ–¹æ³•)
- [é€šçŸ¥ç¤ºä¾‹](#é€šçŸ¥ç¤ºä¾‹)
- [æ‰©å±•åŠŸèƒ½](#æ‰©å±•åŠŸèƒ½)

---

## åŠŸèƒ½æ¦‚è¿°

### éœ€æ±‚èƒŒæ™¯

é˜²æ­¢ç”¨æˆ·åˆ†äº«è´¦å·ï¼Œæ£€æµ‹åŒä¸€ä¸ª Emby ç”¨æˆ·åŒæ—¶æ’­æ”¾è¶…è¿‡ 2 è·¯è§†é¢‘æµçš„æƒ…å†µï¼Œå¹¶é€šçŸ¥ç®¡ç†å‘˜ã€‚

### åŠŸèƒ½ç‰¹æ€§

| ç‰¹æ€§ | è¯´æ˜ |
|------|------|
| å®šæ—¶å·¡æ£€ | æ¯éš”æŒ‡å®šæ—¶é—´æ£€æŸ¥ä¸€æ¬¡æ‰€æœ‰æ´»è·ƒä¼šè¯ |
| å¤šæœåŠ¡å™¨æ”¯æŒ | æ”¯æŒæ£€æµ‹æ‰€æœ‰å·²æ³¨å†Œçš„ Emby æœåŠ¡å™¨ |
| ç”¨æˆ·å…³è” | è‡ªåŠ¨å…³è” Emby ç”¨æˆ·ä¸ Telegram ID |
| ç®¡ç†å‘˜é€šçŸ¥ | è¶…æ ‡æ—¶å‘é€è¯¦ç»†ä¿¡æ¯åˆ°ç®¡ç†ç¾¤ |
| å¯é€‰è‡ªåŠ¨å¤„ç† | æ”¯æŒè‡ªåŠ¨ç»ˆæ­¢è¶…æ ‡ä¼šè¯ï¼ˆå¯é…ç½®ï¼‰ |

---

## å®ç°åŸç†

```
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚                    å®šæ—¶ä»»åŠ¡è§¦å‘                          â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
                      â–¼
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚     è°ƒç”¨ Emby API: GET /emby/Sessions                   â”‚
â”‚     è·å–æ‰€æœ‰æ´»è·ƒæ’­æ”¾ä¼šè¯                                  â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
                      â–¼
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚     æŒ‰ UserId åˆ†ç»„ç»Ÿè®¡æ¯ä¸ªç”¨æˆ·çš„å¹¶å‘æ’­æ”¾æ•°                â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
                      â–¼
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚     å¹¶å‘æ•° > é˜ˆå€¼?                                       â”‚
â”‚     â”œâ”€ æ˜¯ â†’ æŸ¥è¯¢æ•°æ®åº“è·å– TG ID â†’ å‘é€é€šçŸ¥ç»™ç®¡ç†å‘˜       â”‚
â”‚     â””â”€ å¦ â†’ è·³è¿‡                                         â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

---

## æ–‡ä»¶æ¸…å•

éœ€è¦ä¿®æ”¹/æ–°å¢çš„æ–‡ä»¶ï¼š

| æ–‡ä»¶è·¯å¾„ | æ“ä½œ | è¯´æ˜ |
|----------|------|------|
| `bot/func_helper/emby.py` | ä¿®æ”¹ | æ·»åŠ  `get_active_sessions()` æ–¹æ³• |
| `bot/scheduler/stream_monitor.py` | **æ–°å»º** | å®šæ—¶æ£€æµ‹ä»»åŠ¡ä¸»é€»è¾‘ |
| `bot/schemas/schemas.py` | ä¿®æ”¹ | æ·»åŠ  `StreamMonitor` é…ç½®æ¨¡å‹ |
| `config_example.json` | ä¿®æ”¹ | æ·»åŠ  `stream_monitor` é…ç½®é¡¹ |
| `main.py` | ä¿®æ”¹ | æ³¨å†Œå®šæ—¶ä»»åŠ¡ |

---

## é…ç½®è¯´æ˜

### config.json é…ç½®é¡¹

```json
{
  "stream_monitor": {
    "enabled": true,
    "interval": 60,
    "max_streams": 2,
    "auto_terminate": false,
    "notify_user": false
  }
}
```

### é…ç½®é¡¹è¯´æ˜

| é…ç½®é¡¹ | ç±»å‹ | é»˜è®¤å€¼ | è¯´æ˜ |
|--------|------|--------|------|
| `enabled` | bool | `false` | æ˜¯å¦å¯ç”¨å¹¶å‘ç›‘æ§ |
| `interval` | int | `60` | æ£€æµ‹é—´éš”ï¼ˆç§’ï¼‰ |
| `max_streams` | int | `2` | æœ€å¤§å…è®¸åŒæ—¶æ’­æ”¾æ•° |
| `auto_terminate` | bool | `false` | è¶…æ ‡æ—¶æ˜¯å¦è‡ªåŠ¨ç»ˆæ­¢å¤šä½™ä¼šè¯ |
| `notify_user` | bool | `false` | æ˜¯å¦ç§ä¿¡é€šçŸ¥è¿è§„ç”¨æˆ· |

---

## ä»£ç å®ç°

### 1. Emby API æ–°å¢æ–¹æ³•

**æ–‡ä»¶**: `bot/func_helper/emby.py`

åœ¨ `Embyservice` ç±»ä¸­æ·»åŠ ï¼š

```python
async def get_active_sessions(self) -> List[Dict]:
    """
    è·å–æ‰€æœ‰æ´»è·ƒæ’­æ”¾ä¼šè¯

    Returns:
        List[Dict]: æ­£åœ¨æ’­æ”¾çš„ä¼šè¯åˆ—è¡¨ï¼Œæ¯ä¸ªä¼šè¯åŒ…å«:
            - user_id: Emby ç”¨æˆ· ID
            - user_name: Emby ç”¨æˆ·å
            - session_id: ä¼šè¯ IDï¼ˆç”¨äºç»ˆæ­¢ä¼šè¯ï¼‰
            - device_name: è®¾å¤‡åç§°
            - client_name: å®¢æˆ·ç«¯åç§°
            - now_playing: æ­£åœ¨æ’­æ”¾çš„å†…å®¹åç§°
            - play_method: æ’­æ”¾æ–¹å¼ï¼ˆDirect/Transcodeï¼‰
    """
    try:
        result = await self._request('GET', '/emby/Sessions')
        if not result.success:
            LOGGER.error(f"è·å–æ´»è·ƒä¼šè¯å¤±è´¥: {result.error}")
            return []

        sessions = []
        for session in result.data:
            # åªå…³æ³¨æ­£åœ¨æ’­æ”¾å†…å®¹çš„ä¼šè¯
            now_playing = session.get("NowPlayingItem")
            if now_playing:
                sessions.append({
                    'user_id': session.get('UserId'),
                    'user_name': session.get('UserName'),
                    'session_id': session.get('Id'),
                    'device_name': session.get('DeviceName', 'æœªçŸ¥è®¾å¤‡'),
                    'client_name': session.get('Client', 'æœªçŸ¥å®¢æˆ·ç«¯'),
                    'now_playing': now_playing.get('Name', 'æœªçŸ¥å†…å®¹'),
                    'play_method': session.get('PlayState', {}).get('PlayMethod', 'Unknown')
                })

        LOGGER.debug(f"è·å–åˆ° {len(sessions)} ä¸ªæ´»è·ƒæ’­æ”¾ä¼šè¯")
        return sessions

    except Exception as e:
        LOGGER.error(f"è·å–æ´»è·ƒä¼šè¯å¼‚å¸¸: {str(e)}")
        return []
```

### 2. é…ç½®æ¨¡å‹

**æ–‡ä»¶**: `bot/schemas/schemas.py`

æ·»åŠ é…ç½®ç±»ï¼š

```python
class StreamMonitor(BaseModel):
    """å¹¶å‘æ’­æ”¾ç›‘æ§é…ç½®"""
    enabled: bool = False
    interval: int = 60
    max_streams: int = 2
    auto_terminate: bool = False
    notify_user: bool = False
```

åœ¨ `Config` ç±»ä¸­æ·»åŠ ï¼š

```python
class Config(BaseModel):
    # ... å…¶ä»–é…ç½® ...
    stream_monitor: StreamMonitor = StreamMonitor()
```

### 3. å®šæ—¶ä»»åŠ¡

**æ–‡ä»¶**: `bot/scheduler/stream_monitor.py`ï¼ˆæ–°å»ºï¼‰

```python
"""
å¹¶å‘æ’­æ”¾ç›‘æ§ - æ£€æµ‹åŒä¸€ç”¨æˆ·åŒæ—¶æ’­æ”¾è¶…è¿‡é˜ˆå€¼çš„æƒ…å†µ
"""
from collections import defaultdict
from pyrogram.errors import FloodWait
from asyncio import sleep

from bot import bot, group, LOGGER, config
from bot.func_helper.emby_manager import emby_manager
from bot.sql_helper.sql_emby import sql_get_emby


async def check_concurrent_streams():
    """
    æ£€æµ‹å¤šè·¯å¹¶å‘æ’­æ”¾

    éå†æ‰€æœ‰ Emby æœåŠ¡å™¨ï¼Œæ£€æŸ¥æ˜¯å¦æœ‰ç”¨æˆ·åŒæ—¶æ’­æ”¾è¶…è¿‡é˜ˆå€¼çš„è§†é¢‘æµ
    """
    max_streams = config.stream_monitor.max_streams
    auto_terminate = config.stream_monitor.auto_terminate
    notify_user = config.stream_monitor.notify_user

    LOGGER.debug(f"ã€å¹¶å‘ç›‘æ§ã€‘å¼€å§‹æ£€æµ‹ï¼Œé˜ˆå€¼: {max_streams} è·¯")

    for server_id in emby_manager.list_server_ids():
        emby_service = emby_manager.get_server(server_id)
        if not emby_service:
            continue

        server_name = emby_manager.get_server_config(server_id).name

        # è·å–æ‰€æœ‰æ´»è·ƒä¼šè¯
        sessions = await emby_service.get_active_sessions()
        if not sessions:
            continue

        # æŒ‰ç”¨æˆ·åˆ†ç»„
        user_streams = defaultdict(list)
        for session in sessions:
            user_streams[session['user_id']].append(session)

        # æ£€æµ‹è¶…æ ‡ç”¨æˆ·
        for user_id, streams in user_streams.items():
            stream_count = len(streams)

            if stream_count > max_streams:
                await handle_violation(
                    server_id=server_id,
                    server_name=server_name,
                    user_id=user_id,
                    streams=streams,
                    max_streams=max_streams,
                    emby_service=emby_service,
                    auto_terminate=auto_terminate,
                    notify_user=notify_user
                )


async def handle_violation(
    server_id: str,
    server_name: str,
    user_id: str,
    streams: list,
    max_streams: int,
    emby_service,
    auto_terminate: bool,
    notify_user: bool
):
    """
    å¤„ç†è¿è§„ç”¨æˆ·

    Args:
        server_id: æœåŠ¡å™¨ ID
        server_name: æœåŠ¡å™¨åç§°
        user_id: Emby ç”¨æˆ· ID
        streams: è¯¥ç”¨æˆ·çš„æ‰€æœ‰æ’­æ”¾ä¼šè¯
        max_streams: æœ€å¤§å…è®¸æµæ•°
        emby_service: Emby æœåŠ¡å®ä¾‹
        auto_terminate: æ˜¯å¦è‡ªåŠ¨ç»ˆæ­¢
        notify_user: æ˜¯å¦é€šçŸ¥ç”¨æˆ·
    """
    stream_count = len(streams)
    emby_name = streams[0]['user_name']

    # æŸ¥è¯¢å¯¹åº”çš„ TG ID
    user = sql_get_emby(user_id)
    tg_id = user.tg if user else None
    tg_display = f"`{tg_id}`" if tg_id else "æœªå…³è”"

    # æ„å»ºè®¾å¤‡è¯¦æƒ…
    device_lines = []
    for i, s in enumerate(streams, 1):
        device_lines.append(
            f"  {i}. {s['device_name']} ({s['client_name']})\n"
            f"     â””â”€ {s['now_playing']}"
        )
    devices_text = "\n".join(device_lines)

    # æ„å»ºç®¡ç†å‘˜é€šçŸ¥æ¶ˆæ¯
    admin_text = (
        f"âš ï¸ **å¹¶å‘æ’­æ”¾è¶…æ ‡**\n"
        f"â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”\n"
        f"ğŸ‘¤ ç”¨æˆ·: `{emby_name}`\n"
        f"ğŸ†” TG ID: {tg_display}\n"
        f"ğŸ–¥ï¸ æœåŠ¡å™¨: {server_name}\n"
        f"ğŸ“º å½“å‰æ’­æ”¾: **{stream_count}** è·¯ï¼ˆä¸Šé™ {max_streams}ï¼‰\n"
        f"â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”\n"
        f"ğŸ“± è®¾å¤‡è¯¦æƒ…:\n{devices_text}"
    )

    # è‡ªåŠ¨ç»ˆæ­¢å¤„ç†
    terminated = []
    if auto_terminate and stream_count > max_streams:
        # ä¿ç•™æœ€æ—©çš„ max_streams ä¸ªä¼šè¯ï¼Œç»ˆæ­¢å…¶ä½™çš„
        sessions_to_terminate = streams[max_streams:]
        for session in sessions_to_terminate:
            success = await emby_service.terminate_session(
                session['session_id'],
                reason="è¶…å‡ºå¹¶å‘æ’­æ”¾é™åˆ¶"
            )
            if success:
                terminated.append(session['device_name'])

        if terminated:
            admin_text += f"\n\nğŸ”´ å·²è‡ªåŠ¨ç»ˆæ­¢: {', '.join(terminated)}"

    # å‘é€ç®¡ç†å‘˜é€šçŸ¥
    try:
        await bot.send_message(group[0], admin_text)
        LOGGER.warning(
            f"ã€å¹¶å‘ç›‘æ§ã€‘è¶…æ ‡ç”¨æˆ·: {emby_name} (TG:{tg_id}) "
            f"- {stream_count}è·¯ @ {server_name}"
        )
    except FloodWait as f:
        await sleep(f.value * 1.2)
        await bot.send_message(group[0], admin_text)
    except Exception as e:
        LOGGER.error(f"ã€å¹¶å‘ç›‘æ§ã€‘å‘é€é€šçŸ¥å¤±è´¥: {e}")

    # ç§ä¿¡é€šçŸ¥ç”¨æˆ·
    if notify_user and tg_id:
        user_text = (
            f"âš ï¸ **æ’­æ”¾æé†’**\n\n"
            f"æ£€æµ‹åˆ°æ‚¨çš„è´¦æˆ· `{emby_name}` åŒæ—¶æ’­æ”¾ **{stream_count}** è·¯è§†é¢‘ï¼Œ"
            f"è¶…å‡ºäº†å…è®¸çš„ {max_streams} è·¯é™åˆ¶ã€‚\n\n"
            f"è¯·å…³é—­å¤šä½™çš„æ’­æ”¾è®¾å¤‡ï¼Œå¦åˆ™å¯èƒ½å½±å“æ‚¨çš„è´¦æˆ·ä½¿ç”¨ã€‚"
        )
        if terminated:
            user_text += f"\n\nå·²è‡ªåŠ¨æ–­å¼€: {', '.join(terminated)}"

        try:
            await bot.send_message(tg_id, user_text)
        except Exception as e:
            LOGGER.error(f"ã€å¹¶å‘ç›‘æ§ã€‘é€šçŸ¥ç”¨æˆ·å¤±è´¥ TG:{tg_id} - {e}")
```

### 4. æ³¨å†Œå®šæ—¶ä»»åŠ¡

**æ–‡ä»¶**: `main.py`

åœ¨å®šæ—¶ä»»åŠ¡æ³¨å†ŒåŒºåŸŸæ·»åŠ ï¼š

```python
# å¹¶å‘æ’­æ”¾ç›‘æ§
if config.stream_monitor.enabled:
    from bot.scheduler.stream_monitor import check_concurrent_streams
    scheduler.add_job(
        check_concurrent_streams,
        'interval',
        seconds=config.stream_monitor.interval,
        id='stream_monitor',
        name='å¹¶å‘æ’­æ”¾ç›‘æ§'
    )
    LOGGER.info(f"ã€å®šæ—¶ä»»åŠ¡ã€‘å¹¶å‘æ’­æ”¾ç›‘æ§å·²å¯ç”¨ï¼Œé—´éš” {config.stream_monitor.interval} ç§’")
```

---

## ä½¿ç”¨æ–¹æ³•

### 1. å¯ç”¨åŠŸèƒ½

ç¼–è¾‘ `config.json`ï¼š

```json
{
  "stream_monitor": {
    "enabled": true,
    "interval": 60,
    "max_streams": 2,
    "auto_terminate": false,
    "notify_user": false
  }
}
```

### 2. é‡å¯ Bot

```bash
# Docker æ–¹å¼
docker restart embybot

# ç›´æ¥è¿è¡Œ
python main.py
```

### 3. éªŒè¯è¿è¡Œ

æŸ¥çœ‹æ—¥å¿—ç¡®è®¤ä»»åŠ¡å·²æ³¨å†Œï¼š

```
INFO - ã€å®šæ—¶ä»»åŠ¡ã€‘å¹¶å‘æ’­æ”¾ç›‘æ§å·²å¯ç”¨ï¼Œé—´éš” 60 ç§’
```

---

## é€šçŸ¥ç¤ºä¾‹

### ç®¡ç†å‘˜æ”¶åˆ°çš„é€šçŸ¥

```
âš ï¸ å¹¶å‘æ’­æ”¾è¶…æ ‡
â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”
ğŸ‘¤ ç”¨æˆ·: test_user
ğŸ†” TG ID: 123456789
ğŸ–¥ï¸ æœåŠ¡å™¨: ä¸»æœåŠ¡å™¨
ğŸ“º å½“å‰æ’­æ”¾: 3 è·¯ï¼ˆä¸Šé™ 2ï¼‰
â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”
ğŸ“± è®¾å¤‡è¯¦æƒ…:
  1. iPhone 15 (Infuse)
     â””â”€ ç”„å¬›ä¼  S01E05
  2. MacBook Pro (Emby Web)
     â””â”€ ç‹‚é£™ S01E12
  3. å°ç±³ç”µè§† (Emby Theater)
     â””â”€ ä¸‰ä½“ S01E01
```

### å¼€å¯è‡ªåŠ¨ç»ˆæ­¢å

```
âš ï¸ å¹¶å‘æ’­æ”¾è¶…æ ‡
...ï¼ˆåŒä¸Šï¼‰...

ğŸ”´ å·²è‡ªåŠ¨ç»ˆæ­¢: å°ç±³ç”µè§†
```

---

## æ‰©å±•åŠŸèƒ½

### 1. ç™½åå•ç”¨æˆ·è±å…

å¯ä»¥ä¸ºç™½åå•ç”¨æˆ·ï¼ˆ`lv='a'`ï¼‰è®¾ç½®æ›´é«˜çš„å¹¶å‘é™åˆ¶ï¼š

```python
# åœ¨ handle_violation å‡½æ•°å¼€å¤´æ·»åŠ 
if user and user.lv == 'a':
    whitelist_max = max_streams + 2  # ç™½åå•å¤šç»™2è·¯
    if stream_count <= whitelist_max:
        return  # ç™½åå•ç”¨æˆ·æœªè¶…æ ‡ï¼Œè·³è¿‡
```

### 2. è¿è§„è®¡æ•°ä¸è‡ªåŠ¨å°ç¦

è®°å½•ç”¨æˆ·è¿è§„æ¬¡æ•°ï¼Œå¤šæ¬¡è¿è§„åè‡ªåŠ¨å°ç¦ï¼š

```python
# ä½¿ç”¨ Redis æˆ–æ•°æ®åº“è®°å½•è¿è§„æ¬¡æ•°
violation_count = get_violation_count(user_id)
if violation_count >= 3:
    await emby_service.emby_change_policy(user_id, disable=True)
    # é€šçŸ¥ç”¨æˆ·å·²è¢«å°ç¦
```

### 3. æ‰‹åŠ¨è§¦å‘æ£€æµ‹

æ·»åŠ ç®¡ç†å‘˜å‘½ä»¤æ‰‹åŠ¨è§¦å‘æ£€æµ‹ï¼š

```python
@bot.on_message(filters.command("check_streams") & filters.user(admins + [owner]))
async def cmd_check_streams(client, message):
    await message.reply("æ­£åœ¨æ£€æµ‹å¹¶å‘æ’­æ”¾...")
    await check_concurrent_streams()
    await message.reply("æ£€æµ‹å®Œæˆ")
```

---

## æ³¨æ„äº‹é¡¹

1. **æ£€æµ‹é—´éš”**ï¼šå»ºè®®ä¸è¦è®¾ç½®è¿‡çŸ­ï¼ˆ<30ç§’ï¼‰ï¼Œé¿å…å¯¹ Emby æœåŠ¡å™¨é€ æˆå‹åŠ›
2. **è‡ªåŠ¨ç»ˆæ­¢**ï¼šè°¨æ…å¼€å¯ï¼Œå¯èƒ½å½±å“ç”¨æˆ·ä½“éªŒï¼Œå»ºè®®å…ˆè§‚å¯Ÿä¸€æ®µæ—¶é—´
3. **ç½‘ç»œå»¶è¿Ÿ**ï¼šç”¨æˆ·åˆ‡æ¢è®¾å¤‡æ—¶å¯èƒ½çŸ­æš‚å‡ºç°å¤šè·¯æƒ…å†µï¼Œå¯è€ƒè™‘æ·»åŠ å®¹å¿æ—¶é—´
4. **Emby è‡ªå¸¦é™åˆ¶**ï¼šEmby æœ¬èº«æœ‰ `SimultaneousStreamLimit` é™åˆ¶ï¼Œæœ¬åŠŸèƒ½ä¸»è¦ç”¨äºç›‘æ§å’Œé€šçŸ¥

---

## ç›¸å…³æ–‡ä»¶

- [ç”¨æˆ·æŒ‡å—](./USER_GUIDE.md)
- [å‘½ä»¤åˆ—è¡¨](./COMMANDS.md)
- [å¤šæœåŠ¡å™¨é…ç½®](./multi-server-quickstart.md)
